basetest 에 버전1찍고 이미지생성, 추가된 부분만 이미지 생성됨

image ls 해보면 수정된 부분 반영 확인 할수 있ㅇㅁ
image push 하면 이미지 도커허브에 밀어넣기 -> 이때 인증안되면 도커 로그인

pulltest로 이동하고 로컬의 basetest갖고 베이스이미지로 
ls하면 
변경하고 나서 build
변경 안하고 build 해보면 차이를 알수있음

이때 베이스인 basetest의 도커파일 수정한다 버전 2로
이미지 ㅣls하면 기존 bastest는 태그가 none되고새롭게 추가됨 -> dangling 상태로 바뀜(none)
dangling -> 하드디스크 용량 많이 차지 => 태그 관리 필요

basetest를 docker hub에 푸시
pulltest도 다시 빌드임
이미지 ls 하면 pulltest라는 것이 레포지랑 태그 none으로 바뀌고 새로 추가됨



# 9/15(화)

## 태깅되지 않은 이미지를 검색 및 태그

### 태깅되지 않은 이미지 검색
- vagrant@xenial64:~/pulltest$ docker image ls -f "dangling=true"
~~~~
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              fefad6ab4ef6        11 minutes ago      1.23MB
~~~~
- vagrant@xenial64:~/pulltest$ docker image ls -f "dangling=true"  => 하면 이미지id 나옴

### 이미지에 태그를 변경 방법
- vagrant@xenial64:~/pulltest$ docker image tag --help
~~~~
Usage:  docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
~~~~

### 태킹되지 않은 이미지에 태그를 추가
- vagrant@xenial64:~/pulltest$ docker image tag $(docker image ls -f "dangling=true" -q) myanjini/basetest:0.1 ( $(): 태깅할 이미지 식별자(id또는 이름)
, 뒤의것은: 부여할 이미지 이름
- vagrant@xenial64:~/pulltest$ docker image ls
~~~~
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myanjini/pulltest   latest              181d7129cf05        6 minutes ago       1.23MB
myanjini/basetest   lastest             e17d780478cf        11 minutes ago      1.23MB
myanjini/basetest   latest              e17d780478cf        11 minutes ago      1.23MB

myanjini/basetest   0.1                 fefad6ab4ef6        14 minutes ago      1.23MB 
~~~~


## Dockerfile로 이미지 빌드 시 주의사항

- 이미지 빌드가 완료되면 Dockerfile의 명령어 줄 수 만큼의 레이어가 존재
- 실제 컨테이너에서 사용하지 못하는 파일(디렉터리)이 이미지 레이어에 존재하면 공간만 차지하게 됨
- ⇒ Dockerfile을 작성할 때 &&로 각 RUN 명령어를 하나로 묶어서 실행

### 3개의 RUN 명령어 실행 → 실제 이미지 내부에 변경은 없음 (100M 크기의 파일을 생성 후 삭제하므로)
- vagrant@xenial64:~/pulltest$ mkdir ~/dockerfile_test && cd ~/dockerfile_test

### vagrant@xenial64:~/dockerfile_test$ vi Dockerfile
~~~~
FROM ubuntu

RUN  mkdir /test

RUN  fallocate  -l  100m  /test/dumy

RUN  rm  /test/dumy
~~~~

- vagrant@xenial64:~/dockerfile_test$ docker image build -t falloc_100m .

- vagrant@xenial64:~/dockerfile_test$ docker image ls
~~~~
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
falloc_100m         latest              cb419b52df77        23 seconds ago      179MB
myanjini/pulltest   latest              181d7129cf05        18 minutes ago      1.23MB
myanjini/basetest   lastest             e17d780478cf        22 minutes ago      1.23MB
myanjini/basetest   latest              e17d780478cf        22 minutes ago      1.23MB
myanjini/basetest   0.1                 fefad6ab4ef6        25 minutes ago      1.23MB
myanjini/basetest   <none>              54d6c33b5a41        29 minutes ago      1.23MB
busybox             latest              6858809bf669        5 days ago          1.23MB
ubuntu              latest              4e2eef94cd6b        3 weeks ago         73.9MB
~~~~

### 3개의 RUN 명령어를 하나로 줄여서 실행
- vagrant@xenial64:~/dockerfile_test$ vi Dockerfile
~~~~
FROM ubuntu

RUN  mkdir /test  &&  fallocate  -l  100m  /test/dumy  &&  rm  /test/dumy
~~~~

- vagrant@xenial64:~/dockerfile_test$ docker build -t recommand .

- vagrant@xenial64:~/dockerfile_test$ docker image ls
~~~~
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
recommand           latest              6a667c9fadb5        4 seconds ago       73.9MB 

falloc_100m         latest              cb419b52df77        3 minutes ago       179MB

ubuntu              latest              4e2eef94cd6b        3 weeks ago         73.9MB
~~~~



## 도커 컨테이너 생명주기 
- 이미지 가져오기 : 도커 허브에서 pull(허브에 이미지 올리기 push), 이미지 빌드(생성), 만들어진 이미지를 commit
- 도커파일로 이미지 빌드 가능, 실행되고 있는 이미지 커밋으로 이미지 만들기 - 레포지에 올라옴 -> 도커푸시하면 도커허브로, 풀하면 원격 도커 허브에서 로컬로 
- 도커런하면 크리에이드 하고 실행됨 (create, + start) 
![캡처1](https://user-images.githubusercontent.com/38436013/93153039-39054800-f73b-11ea-995e-2c349df94c73.JPG)

## docker container run 명령의 인자를 이용해서 CMD 명령을 오버라이드 (P64)

- alpin을 컨테이너 생성하면 네부에 쉘 실행
- run 하면 이미지 뒤에 있는 명령어를 컨테이너 내부에서 싱행 됨을 의미함 , 앞에 있는 cmd 무시
- add 압축해제 cmd 쉘에서실행
### libray/alpine:latest 이미지의 Dockerfile 확인
- https://hub.docker.com/_/alpine
- https://github.com/alpinelinux/docker-alpine/blob/90788e211ec6d5df183d79d6cb02e068b258d198/x86_64/Dockerfile
~~~~
FROM scratch
ADD alpine-minirootfs-3.12.0-x86_64.tar.gz /
CMD ["/bin/sh"]
~~~~

### alipne 이미지를 이용해서 컨테이너를 생성
- 쉘에다가 입력하려면 -it 주어야 
- vagrant@xenial64:~$ docker container run -it alpine
~~~~
/ # uname -a						⇐ 컨테이너가 생성되면 컨테이너 내부에 쉘을 실행
Linux 935620ae9dd7 4.4.0-1
89-generic #219-Ubuntu SMP Tue Aug 11 12:26:50 UTC 2020 x86_64 Linux
/ # ls
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
/ # exit
~~~~
### CMD 명령을 오버라이드, 이미지 이름 뒤에 명령어 주면 오버라이드 되어서 실행결과가 출력됨, 
~~~~
vagrant@xenial64:~$ docker container run -it alpine uname -a
Linux 9bf859f09b0f 4.4.0-189-generic #219-Ubuntu SMP Tue Aug 11 12:26:50 UTC 2020 x86_64 Linux  ⇐ uname -a 결과

vagrant@xenial64:~$ docker container run -it alpine ls
bin    etc    lib    mnt    proc   run    srv    tmp    var
dev    home   media  opt    root   sbin   sys    usr

vagrant@xenial64:~$ docker container run -it alpine ip a
~~~~



## 컨테이너 목록 필터링
### 테스트를 위해 이미지 생성하고 컨테이너를 실행
- vagrant@xenial64:~/chap02$ docker image build -t example/echo:latest .
- vagrant@xenial64:~/chap02$ docker container run -d -p 9000:8080 example/echo:latest
- => 46c40acffd83c0cdf6770aa993683697b51729a5ea4b7c6e34bdd50047702215
- vagrant@xenial64:~/chap02$ docker container ls

### 컨테이너 이름을 부여해서 실행(하나 더 만듦)
- vagrant@xenial64:~/chap02$ docker container run -d -p 9001:8080 **--name myecho** example/echo:latest
- =>b10088f2914a82b77bbd759586156fbad3719552079dfb7644b3ad72cc50ba3c

- vagrant@xenial64:~/chap02$ docker container ls
~~~~
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
b10088f2914a        example/echo:latest   "go run /echo/main.go"   7 seconds ago       Up 6 seconds        0.0.0.0:9001->8080/tcp   myecho
46c40acffd83        example/echo:latest   "go run /echo/main.go"   2 minutes ago       Up 2 minutes        0.0.0.0:9000->8080/tcp   epic_spence
~~~~
### 중지된 상태의 컨테이너를 포함해서 조회 , -a는 중지된 상태도 조회
- vagrant@xenial64:~/chap02$ docker container ls -a
### 컨터이너 이름으로 조회
- vagrant@xenial64:~/chap02$ docker container ls -a --filter "name=myecho"
### 컨테이너 생성에 사용한 이미지로 조회 (사용자명/이미지명 형식으로 조회)
- vagrant@xenial64:~/chap02$ docker container ls -a --filter "ancestor=example/echo:latest"
- (vagrant@xenial64:~/chap02$ docker container ls -a --filter "ancestor=example/echo") 위와 같은 결과
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
b10088f2914a        example/echo:latest   "go run /echo/main.go"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   myecho
46c40acffd83        example/echo:latest   "go run /echo/main.go"   6 minutes ago       Up 6 minutes        0.0.0.0:9000->8080/tcp   epic_spence



## quiz
~~~~~
Quiz.
태그가 다른 이미지를 이용해서 실행한 컨테이너를 ancestro 필터로 검색할 경우 결과는 어떻게 될까?

#1 example/echo:latest 이미지를 example/echo:old로 태그를 변경
vagrant@xenial64:~/chap02$ docker image tag example/echo:latest example/echo:old
vagrant@xenial64:~/chap02$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
example/echo        latest              16a4c3b0f222        18 minutes ago      750MB
example/echo        old                 16a4c3b0f222        18 minutes ago      750MB


#2 example/echo:old 이미지로 컨테이너를 생성
vagrant@xenial64:~/chap02$ docker container run -d -p 9002:8080 --name myoldecho example/echo:old
e04df49d7bea5364999e2311acc3f80b5586b9d1da21c215112e20286174ffa2

vagrant@xenial64:~/chap02$ docker container ls
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
e04df49d7bea        example/echo:old      "go run /echo/main.go"   10 seconds ago      Up 9 seconds        0.0.0.0:9002->8080/tcp   myoldecho
b10088f2914a        example/echo:latest   "go run /echo/main.go"   16 minutes ago      Up 16 minutes       0.0.0.0:9001->8080/tcp   myecho
46c40acffd83        example/echo:latest   "go run /echo/main.go"   18 minutes ago      Up 18 minutes       0.0.0.0:9000->8080/tcp   epic_spence

#3 ancestor=example/echo로 검색
vagrant@xenial64:~/chap02$ docker container ls --filter "ancestor=example/echo"
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
e04df49d7bea        example/echo:old      "go run /echo/main.go"   54 seconds ago      Up 53 seconds       0.0.0.0:9002->8080/tcp   myoldecho
b10088f2914a        example/echo:latest   "go run /echo/main.go"   17 minutes ago      Up 17 minutes       0.0.0.0:9001->8080/tcp   myecho
46c40acffd83        example/echo:latest   "go run /echo/main.go"   19 minutes ago      Up 19 minutes       0.0.0.0:9000->8080/tcp   epic_spence

#4 ancestor=example/echo:latest로 검색
vagrant@xenial64:~/chap02$ docker container ls --filter "ancestor=example/echo:latest"
CONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS              PORTS                    NAMES
e04df49d7bea        example/echo:old      "go run /echo/main.go"   About a minute ago   Up 59 seconds       0.0.0.0:9002->8080/tcp   myoldecho
b10088f2914a        example/echo:latest   "go run /echo/main.go"   17 minutes ago       Up 17 minutes       0.0.0.0:9001->8080/tcp   myecho
46c40acffd83        example/echo:latest   "go run /echo/main.go"   19 minutes ago       Up 19 minutes       0.0.0.0:9000->8080/tcp   epic_spence

#3번과 #4번의 결과가 같을까? 다를까?
⇒ 같다 ⇒ 필터링에 사용하는 이미지는 "사용자명/이미지명"까지만 식별 

~~~~~


## 출력 형식 지정
- https://docs.docker.com/engine/reference/commandline/ps/ 에 정보 있음
- vagrant@xenial64:~/chap02$ docker container ls -a --format "table {{.ID}} : {{.Names}}\t{{.Command}}"
~~~~
CONTAINER ID : NAMES                COMMAND
e04df49d7bea : myoldecho            "go run /echo/main.go"
b10088f2914a : myecho               "go run /echo/main.go"
~~~~
## 컨테이너 정지
- vagrant@xenial64:~/chap02$ docker container stop myoldecho	⇐ 컨테이너 이름
- vagrant@xenial64:~/chap02$ docker container stop b10088f2914a	⇐ 컨테이너 ID
- vagrant@xenial64:~/chap02$ docker container stop 46		⇐ 컨테이너 ID 일부 (앞에서 부터 식별 가능한 범위)

- 확인
- vagrant@xenial64:~/chap02$ docker container ps
- CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

## 컨테이너 재시작 : 삭제와 방식 같다
- vagrant@xenial64:~/chap02$ docker container restart myoldecho	⇐ 컨테이너 이름
- vagrant@xenial64:~/chap02$ docker container ls


## 컨테이너 삭제
### 중지 상태인 컨테이너 삭제
- 1 중지 상태인 컨테이너를 조회
- vagrant@xenial64:~/chap02$ docker container ls --filter "status=exited"
- 2 중지 상태인 컨터이너의 ID를 조회
- vagrant@xenial64:~/chap02$ docker container ls --filter "status=exited" -q
- 3 중지 상태인 컨테이너를 일괄 삭제
- vagrant@xenial64:~/chap02$ docker container rm $(docker container ls --filter "status=exited" -q
- vagrant@xenial64:~/chap02$ docker container ls --filter "status=exited"
### 모든 컨테이너를 삭제
~~~~~
vagrant@xenial64:~/chap02$ docker container rm -f $(docker container ls -a -q)
                                            ~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~ 
                                                     모든 상태의 컨테이너의 ID를 조회
                                            실행 중인 컨테이너는 중지하고 삭제   
~~~~~


## 컨테이너를 중지할 때 컨테이너를 자동으로 삭제
### 컨테이너를 중지하면 Exited 상태로 대기 ⇒ restart 명령으로 재기동 가능
- vagrant@xenial64:~/chap02$ docker container run -d -p 9000:8080 example/echo:latest
- f02810866949ba9d9c8ed7344d3c4da1daa8147994d92b83bae533666eca4b92

- vagrant@xenial64:~/chap02$ docker container stop f02810866949ba9d9c8ed7344d3c4da1daa8147994d92b83bae533666eca4b92
- f02810866949ba9d9c8ed7344d3c4da1daa8147994d92b83bae533666eca4b92

- vagrant@xenial64:~/chap02$ docker container ps -a
~~~~
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                     PORTS               NAMES
f02810866949        example/echo:latest   "go run /echo/main.go"   23 seconds ago      Exited (2) 6 seconds ago                       thirsty_hawking
~~~~

### 컨테이너 생성 시 --rm 옵션을 추가하면 컨테이너를 중지하면 해당 컨테이너를 삭제

- vagrant@xenial64:~/chap02$ docker container run -d -p 9000:8080 --rm example/echo:latest
- 6be50783d1ecd8f8dcfda8c075509a1bc0143d141cf3295616fcf311bfff74ec

- vagrant@xenial64:~/chap02$ docker container ps
~~~~
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
6be50783d1ec        example/echo:latest   "go run /echo/main.go"   6 seconds ago       Up 5 seconds        0.0.0.0:9000->8080/tcp   clever_elbakyan
~~~~
- vagrant@xenial64:~/chap02$ docker container stop 6be50783d1ec

- vagrant@xenial64:~/chap02$ docker container ps -a
~~~~
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                     PORTS               NAMES
f02810866949        example/echo:latest   "go run /echo/main.go"   3 minutes ago       Exited (2) 2 minutes ago                       thirsty_hawking
~~~~
 
 
## 컨테이너 내부의 표준 출력을 호스트로 연결
~~~~
vagrant@xenial64:~/chap02$ docker container run -d -p 8080:8080 -p 5000:5000 jenkins
                                                                             ~~~~~~~
                                                            		도커에서 공식 배포하는 최신 버전(latest)
                                                            		⇒ libary/jenkins:latest 같은 의미
~~~~
- vagrant@xenial64:~/chap02$ docker container ls
~~~~
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                                       NAMES
406959fb618b        jenkins             "/bin/tini -- /usr/l…"   About a minute ago   Up About a minute   0.0.0.0:5000->5000/tcp, 0.0.0.0:8080->8080/tcp, 50000/tcp   fervent_heyrovsky
~~~~


## 실행중인 컨테이너 내부로 명령을 전달(실행)
### docker container exec 컨테이너이름 명령어, exec : 실행하고 있는 컨테이너 내부 조작
- vagrant@xenial64:~/chap02$ docker container run -t -d --name echo --rm example/echo:latest
- => 795009969b4719481861c339a06652a863dd9308b65a81fa8c64badbfbecabc4

- vagrant@xenial64:~/chap02$ docker container exec echo pwd
- => /go
- vagrant@xenial64:~/chap02$ docker container exec echo ip a

- vagrant@xenial64:~/chap02$ docker container logs -f 406959fb618b

### 컨테이너 내부 쉘을 이용,  exec -it  ~~ /bin/sh
- vagrant@xenial64:~/chap02$ docker container exec -it echo /bin/sh
- 쉘을 제공하고 인터렉션 할 수 있도록 제공하기 위해 -it가 필요 exec -it , 실행된 쉘 이용하려면 -it 반드시 


## 호스트의 파일 또는 디렉터리를 컨테이너 내부로 복사
### docker container cp 호스트경로 컨테이너이름:컨테이너내부경로
###호스트의 현재 시간을 파일로 생성
- vagrant@xenial64:~/chap02$ date > host_now

- vagrant@xenial64:~/chap02$ cat host_now
- => Tue Sep 15 02:38:55 UTC 2020

### 호스트의 파일을 echo 컨테이너 내부로 복사
- vagrant@xenial64:~/chap02$ docker container cp ./host_now echo:/tmp/

### 컨테이너로 복사한 파일의 내용을 확인
- vagrant@xenial64:~/chap02$ docker container exec echo cat /tmp/host_now
- => Tue Sep 15 02:38:55 UTC 2020


## 컨테이너 내부의 파일을 호스트로 복사
### docker container cp 컨테이너이름:컨테이너내부경로 호스트경로
- vagrant@xenial64:~/chap02$ docker container cp echo:/tmp/host_now  ./host_now_from_container

- vagrant@xenial64:~/chap02$ cat ./host_now_from_container
- => Tue Sep 15 02:38:55 UTC 2020


## 불필요한 컨테이너 및 이미지 삭제

- vagrant@xenial64:~/chap02$ docker container prune
- => WARNING! This will remove all stopped containers.
- 중지하고 있는 컨테이너 삭제

- vagrant@xenial64:~/chap02$ docker image prune
- => WARNING! This will remove all dangling images.
- 참조하고 있는 이미지는 먼저 참조 이미지 삭제해 주어야 함, 댕글링된 이미지 삭제


## LAB. 특정 웹 페이지를 포함하고 있는 웹 서버 이미지를 생성 ************이부분 복습하기
- http://localhost:8080/hello.html 요청하면 hello docker 메시지를 반환하는 웹 서비스를 제공하는 이미지를 생성

## 첫번째 방식. 우분투 이미지를 이용해서 컨테이너를 실행하고 컨테이너 내부를 변경한 후 이미지를 생성
### 1 작업 디렉터리 생성
- vagrant@xenial64:~/chap02$ mkdir ~/webserver && cd ~/webserver
- vagrant@xenial64:~/webserver$

### 2 hello.html 파일을 생성
- vagrant@xenial64:~/webserver$ echo "hello docker" > hello.html
- vagrant@xenial64:~/webserver$ cat hello.html
- => hello docker

### 3 우부투 이미지를 이용해서 컨테이너를 실행 
- vagrant@xenial64:~/webserver$ docker container rm -f myweb
- -> myweb

- vagrant@xenial64:~/webserver$ docker container run -dit -p 8080:80 --name myweb ubuntu:14.04
- => d8337bf2c8199d9227db7bb77986aa51c2457151d63c2311ee27e968136c6393
- -dit 백그라운드에서 돈다,컨테이너 내부에서작업위함  myweb이라는 이름으로 우분트 올림

- vagrant@xenial64:~/webserver$ docker container ls
~~~~
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                       NAMES
d8337bf2c819        ubuntu:14.04        "/bin/bash"         15 seconds ago      Up 14 seconds       0.0.0.0:8080->80/tcp   myweb
~~~~

### 4 컨테이너 내부의 쉘로 접속
- vagrant@xenial64:~/webserver$ docker container exec -it myweb /bin/bash
- root@d8337bf2c819:/# exit
- => exit  

### 5 컨테이너 내부에 아파치 웹 서버를 설치 및 실행
- root@d8337bf2c819:/# apt-get update
- root@d8337bf2c819:/# apt-get install apache2 -y

- root@d8337bf2c819:/# service apache2 status
- => * apache2 is not running
- root@d8337bf2c819:/# service apache2 start
- => * Starting web server apache2                                                                                                         A
- root@d8337bf2c819:/# service apache2 status
- => * apache2 is running

- root@d8337bf2c819:/# ls /var/www/html
- => index.html
- root@d8337bf2c819:/# exit
- => exit

### 6 아파치 웹 서버의 웹 루트에 hello.html 파일을 복사
- vagrant@xenial64:~/webserver$ docker container cp ./hello.html myweb:/var/www/html/
- vagrant@xenial64:~/webserver$ docker container exec myweb cat /var/www/html/hello.html
- => hello docker
- 이떄 ddho exec .......?
### 7 컨테이너로 웹 서비스를 요청
vagrant@xenial64:~/webserver$ curl http://localhost:8080/hello.html
hello docker

### 8 이미지를 생성
vagrant@xenial64:~/webserver$ docker commit myweb myanjini/myweb:latest
sha256:4d477e6f42d06c2e08db4d9f8902a3c89a2beace68291273fc43d7524f5b998c

vagrant@xenial64:~/webserver$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myanjini/myweb      latest              4d477e6f42d0        6 seconds ago       221MB



- 이미 만들어진 이미지를 이용해서웹 서버 구축*************** 가장 중요
- 디장고 앱 만들었어 이걸 앞으로는 디장고가 실행될 수 있도록 하는 이미지가 만들어져 있고 이거승ㄹ 이용해서
- 이것을 다운하고 실행하고 바로 구동 
- 이것을 고급지게 컨테이너컨테이너 연동 -> 블로그
- 블로그 : 마이에스큐엘과 워드프레스 : 도커허브사이트에 환경변수 내용이 나옴,  
- 워드프레스 쓸라면 mysql 변수 연결- 워드프레스 컨테이너랑 , 워드프레스 컨테이너안에서 mysql항상 연결하여 사용 -> link
- 127.17.0.6 mywql 컨테이너임
- 영속적 데이터로 활용 : 컨테이너가 생성한 데이터 보존의 필요 
- 방법 호스트볼륨 과 모든 컨테이너  등..













오류
내 피씨 랑 컨테너 나가는 게이트웨이 부분에 호스트에 dns 추가해주면 된ㄴ데 안되어서 컨테이너에 dns를 수동으로 넣어준다

- docker run -d -e WORDPRESS_DB_PASSWORD=password --name wordpress --link wordpressdb:mysql
워드프레스 컨테이너에서 ㅇㅇ:ㅇㅇ와 같은 비번을 쓰겠다?
- 워드프로세스를 mysql로 명명하겠다? 
그래서 컨테이너 내부에서 mysql로 검색한다

## 컨테이너의 데이터를 영속적(persistent)인 데이터로 활용하는 방법

### 방법1 호스트 볼륨 공유
- v 옵션을 이용해서 호스트 볼륨을 공유
- ⇒ 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트
- ⇒ 이미지에 원재 존재하는 디렉터리에 호스트의 볼륨을 공유하면 컨테이너의 디렉터리 자체가 덮어쓰게 됨

- 펄시스턴트한 저장소 유지하면, 컨테이너가 삭제되더라도 , 또 다른 컨테이너가 볼륨되더라고, 일정한 데이터는 계속 유지 가능
- 볼륨을 공유 한다???? 
